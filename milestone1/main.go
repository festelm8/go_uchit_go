package main

import (
	"fmt"
    "time"
    //"math/rand"
)

//func main(){
//	num,err := strconv.Atoi("10")  // конверт типа данных (в примере из строки в число), два возвращаемых значения ретурн и ерр, где ерр несет в себе инфу об ошибке, если такова будет, ексцепшенов в го нет
//	if err != nil{
//		fmt.Println(err.Error())
//	}
//	fmt.Println(num)
//}


//var a string = "cock" //декларируем переменную через var и указываем тип переменной
//a := "cock" //тоже декларирование, но нет var, его заменяет ":". Тип в данном случае указывать не обязательно, так как компилятор Go способен определить тип по литералу, которым мы инициализируем переменную.


//var x [5]int // создание списка с числами
//var x []float64 //срез, единственное отличие объявления среза от объявления массива — отсутствие указания длины в квадратных скобках.
//a := []string{"kok","world"} // создание списка со строками
//a := make([]string, 5)  //альтернатив способ объявления среза (в примере с 5 пустыми строками)


//x := make(map[string]int) //map являеться типо ассоц массивом НО в отличие от массива карта должна быть инициализирована перед тем, как будет использована функцией make
//x := map[string]string{  //можно без make если сразу заносить значения
//    "H": "Hydrogen",
//    "He": "Helium",
//}


//for i:=0; i<len(a); i++ { //цикл хуле
//	fmt.Println(a[i])
//}


//for k,v := range a{ //в связке с range получаеться этакий foreach
//	fmt.Println(k)
//	fmt.Println(v)
//}


//for _, v := range x { //если скажем k(ключ) не нужен, то компилятор не даст его задекларировать и не использовать, тут как раз _ используеться чтобы сказать компилятору, что переменная нам не нужна
//	fmt.Println(v)
//}


//fmt.Println(Mm(14, 17))

//func Mm(a,b int) int{ //в скобках указываем получаемые данные, во вторых скобках тип возвращаемых данных
//	return a+b
//}


//func f() (int, int) {  //Go способен возвращать несколько значений из функции, для этого необходимы указать несколько типов возвращаемых значений (int, int)
//    return 5, 6
//}
//x, y := f()


//func makeEvenGenerator() func() uint {
//    i := uint(0)
//    return func() (ret uint) { //функцию, использующую переменные, определенные вне этой функции, называют замыканием.
//        ret = i
//        i += 2
//        return
//    }
//}
//nextEven := makeEvenGenerator() //применение - функция, возвращающая другую функцию, которая при вызове генерирует некую последовательность чисел
//fmt.Println(nextEven())


//type Circle struct {  //тип структуры, содержащий именованные поля, чтобы для конкретной цели не держать кучу переменных
//    x, y, r float64
//}
//func (kok *Circle) rUpOnTen() float64 {  //добавляем метод, для описанного между func и названием функции типа
//	kok.r += 10
//    return kok.r
//}
////var kek Circle  //объявляем переменную типа Circle, по умолчанию все поля будут иметь значение 0.0 (поскольку это float)
////kek := Circle{x: 0, y: 0, r: 5}  //можно и сразу все поля определить
//func main(){
//	var kek Circle
//	kek.x = 10
//	kek.y = 5
//	fmt.Println(kek)
//	kek.rUpOnTen()
//	fmt.Println(kek)
//}


//func f(n int) {
//    for i := 0; i < 3; i++ {
//        fmt.Println(n, ":", i)
//        amt := time.Duration(rand.Intn(250))
//        time.Sleep(time.Millisecond * amt)
//    }
//}
//func main() {
//    for i := 0; i < 3; i++ {
//        go f(i)  //запуск проги в отдельный поток
//    }
//    var input string
//    fmt.Scanln(&input)
//}


func pinger(c chan string) {
    for i := 0; ; i++ {
        c <- "ping"  //оператор <- используется для отправки и получения сообщений по каналу, в данном случае опичываеться отправка
    }
}
func ponger(c chan<- string) { //здесь мы задаем направлениесообщение в канале, здесь описываеться что канал будет только отправлять сообщения
    for i := 0; ; i++ {
        c <- "pong"
    }
}
func printer(c <-chan string) { //здесь мы задаем направлениесообщение в канале, здесь описываеться что канал будет только принимать сообщения
    for {
        msg := <- c  //оператор <- используется для отправки сообщений по каналу, в данном случае описываеться получение
        fmt.Println(msg)
        time.Sleep(time.Second * 1)
    }
}
func main() {
    var c chan string = make(chan string) //тип канала представлен ключевым словом chan, за которым следует тип, который будет передаваться по каналу

    go pinger(c)
    go ponger(c)
    go printer(c)

    var input string
    fmt.Scanln(&input)
}